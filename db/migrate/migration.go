package migrate

import (
	"errors"
	"time"

	"github.com/msw-x/moon/ufmt"
	"github.com/msw-x/moon/ustring"
	"github.com/uptrace/bun"
)

type Migration struct {
	bun.BaseModel

	Id         int64     `bun:",pk,autoincrement"`
	Name       string    `bun:",notnull"`
	Comment    string    `bun:",notnull"`
	IsTx       bool      `bun:",notnull"`
	UpHash     string    `bun:",notnull"`
	DownHash   string    `bun:",notnull"`
	UpSql      string    `bun:"-"`
	DownSql    string    `bun:",notnull"`
	GroupId    int64     `bun:",notnull"`
	MigratedAt time.Time `bun:",notnull"`

	Up   func() error `bun:"-"`
	Down func() error `bun:"-"`

	hasUpSql   bool
	hasDownSql bool
}

func (o Migration) String() string {
	return ufmt.NotableJoinWith("_", o.Name, o.Comment)
}

func (o Migration) Error() error {
	if o.IsApplied() && !o.Lost() {
		if !o.UpHashIsValid() && !o.DownHashIsValid() {
			return errors.New("invalid hash")
		} else if !o.UpHashIsValid() {
			return errors.New("invalid up hash")
		} else if !o.DownHashIsValid() {
			return errors.New("invalid down hash")
		}
	}
	return nil
}

func (o *Migration) IsApplied() bool {
	return o.Id > 0
}

func (o *Migration) SetApplied(groupId int64) {
	o.UpHash = ustring.Sha1(o.UpSql)
	o.DownHash = ustring.Sha1(o.DownSql)
	o.GroupId = groupId
	o.MigratedAt = time.Now()
}

func (o *Migration) SetUnapplied() {
	o.Id = 0
	o.UpHash = ""
	o.DownHash = ""
	o.GroupId = 0
	o.MigratedAt = time.Time{}
}

func (o *Migration) Lost() bool {
	return !o.hasUpSql
}

func (o *Migration) UpHashIsValid() bool {
	return o.UpHash == ustring.Sha1(o.UpSql)
}

func (o *Migration) DownHashIsValid() bool {
	return o.DownHash == ustring.Sha1(o.DownSql)
}

func (o *Migration) PreviewDown(c *Context) (string, error) {
	return GenerateDownWithContext(o.UpSql, c)
}

func (o *Migration) GenerateDown(c *Context) (err error) {
	o.DownSql, err = o.PreviewDown(c)
	return
}

func (o *Migration) AutoGenerateDown(c *Context) error {
	if o.hasUpSql && !o.hasDownSql {
		return o.GenerateDown(c)
	} else {
		_, err := o.PreviewDown(c) // for processing of context
		return err
	}
	return nil
}

func (o *Migration) RepairDown(c *Context) (ok bool, err error) {
	if o.IsApplied() && !o.DownHashIsValid() {
		err = o.GenerateDown(c)
		ok = err == nil
		if ok {
			o.DownHash = ustring.Sha1(o.DownSql)
		}
	} else {
		_, err = o.PreviewDown(c) // for processing of contexts
	}
	return
}

func (o *Migration) SetFuncs(db *bun.DB, splitter string) {
	o.Up = func() error {
		return Exec(db, o.UpSql, o.IsTx, splitter)
	}
	o.Down = func() error {
		return Exec(db, o.DownSql, o.IsTx, splitter)
	}
}
